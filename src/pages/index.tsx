import { type NextPage } from "next";
import Head from "next/head";
import { ethers } from "ethers";

import { api } from "~/utils/api";
import { SiweMessage } from "siwe";

import { useRouter } from "next/router";
import {
  useAccount,
  useNetwork,
  useSignMessage,
  useContractRead,
  usePrepareSendTransaction,
  useSendTransaction,
  usePrepareContractWrite,
  useContractWrite,
  useWaitForTransaction,
} from "wagmi";
import {
  usePrepareContractBatchWrite,
  useWaitForAATransaction,
} from "@zerodevapp/wagmi";

import {
  signIn as nextAuthSignIn,
  signOut as nextAuthSignOut,
  useSession,
  getCsrfToken,
} from "next-auth/react";
import { useConnect, useDisconnect } from "wagmi";

const Home: NextPage = () => {
  const { push: navigateTo } = useRouter();
  const { data: session, status } = useSession();

  const { mutateAsync: testAddressPublic } =
    api.example.addressTestPublic.useMutation();

  const { mutateAsync: testAddressProtected } =
    api.example.addressTestProtected.useMutation();

  const {
    address: addressWallet,
    connector: activeConnector,
    isConnected: isAddressConnected,
  } = useAccount();
  const { signMessageAsync } = useSignMessage();
  const { chain } = useNetwork();

  // TODO: fully connected condition: isAddressConnected && status === "authenticated"

  const { data: balanceUSDC } = useContractRead({
    address: "0xbe49ac1EadAc65dccf204D4Df81d650B50122aB2",
    abi: [
      "function balanceOf(address account) external view returns (uint256)",
    ],
    functionName: "balanceOf",
    args: [addressWallet],
  });

  const { config } = usePrepareSendTransaction({
    request: {
      to: ethers.constants.AddressZero,
      value: ethers.utils.parseEther("0"),
    },
  }); // TO FORCE DEPLOY // TODO: do a custom contract in which can check if forcedeployed or not with MINIMAL gas usage

  const { data, isLoading, isSuccess, sendTransaction } = useSendTransaction({
    ...config,
    onSuccess: () => {
      console.log("SENT!!!");
    },
  });
  useWaitForAATransaction({
    wait: data?.wait,
    onSuccess: () => {
      console.log("DONE!!!");
    },
  });

  const handleLogin = async () => {
    if (!signMessageAsync || !addressWallet) return;
    try {
      const callbackUrl = "/protected";
      const message = new SiweMessage({
        domain: window.location.host,
        address: addressWallet,
        statement: "Sign in with Ethereum to the app.",
        uri: window.location.origin,
        version: "1",
        chainId: chain?.id,
        nonce: await getCsrfToken(),
      });
      const preparedMessage = message.prepareMessage();
      const signature = await signMessageAsync({
        message: preparedMessage,
      });
      await nextAuthSignIn("credentials", {
        message: JSON.stringify(message),
        redirect: false,
        signature,
        callbackUrl,
      });
    } catch (error) {
      window.alert(error);
    }
  };

  const signIn = async () => {
    try {
      await handleLogin();
    } catch (e) {
      console.error(e);
      console.log("why err");
    }
  };

  const signOut = async () => {
    //   try {
    //     await ssx?.signOut();
    //   } catch (e) {
    //     console.error(e);
    //   }
    await nextAuthSignOut(); // { callbackUrl: "/" }
  };

  //   const connector = new MetaMaskConnector();
  const { connectAsync, connectors, error, pendingConnector } = useConnect({
    onSuccess: async () => {
      // TODO:
      // 1. deploy contract if not already
      //
      // 2. sign in
      await signIn();
      console.log("SIGNIN COMPLETE");
    },
  });
  const { disconnectAsync } = useDisconnect({
    onSuccess: async () => {
      await signOut();
      console.log("SIGNOUT COMPLETE");
    },
  });

  return (
    <>
      <Head>
        <title>Create T3 App</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div>
        <div>
          {addressWallet} | {status}
        </div>
        {/* <ConnectButton /> */}
        {isAddressConnected && <div>Connected to {activeConnector?.name}</div>}
        {connectors.map((connector) => (
          <button
            disabled={!connector.ready}
            key={connector.id}
            // eslint-disable-next-line
            onClick={async () => {
              await connectAsync({ connector });
            }}
          >
            {connector.name}
            {isLoading &&
              pendingConnector?.id === connector.id &&
              " (connecting)"}
          </button>
        ))}
        <br />
        <button
          // eslint-disable-next-line
          onClick={async () => {
            await disconnectAsync();
          }}
        >
          disconnect
        </button>
        <br />
        <button
          // eslint-disable-next-line
          onClick={async () => {
            await signIn?.();
          }}
        >
          sign in
        </button>
        <br />

        <button
          // eslint-disable-next-line
          onClick={async () => {
            await signOut?.();
          }}
        >
          sign out
        </button>
        <br />
        <button
          // eslint-disable-next-line
          onClick={async () => {
            const addr = await testAddressPublic?.();
            console.log("ADDR public", addr);
          }}
        >
          test public
        </button>
        <br />
        <button
          // eslint-disable-next-line
          onClick={async () => {
            try {
              const addr = await testAddressProtected?.();
              console.log("ADDR protected", addr);
            } catch (e) {
              console.error(e);
            }
          }}
        >
          test protected
        </button>
        <br />
        {/* <button
          disabled={!sendTransaction}
          // eslint-disable-next-line
          onClick={async () => {
            if (!sendTransaction) return;
            // eslint-disable-next-line
            await sendTransaction?.();
          }}
        >
          force deploy
        </button> */}
      </div>
    </>
  );
};

export default Home;
